<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
		<title>Jump Stack</title>
		<script type="text/javascript" src="js/phaser.js"></script>		
		<style>
		  body {
		    padding: 0px;
		    margin: 0px;
		    background-color: black;
		  }
		  </style>
	</head>

	<body>  
		<!-- include the main game file -->
		<script>var JumpStack = JumpStack || {};

JumpStack.Block = function(state, x, y, data) {
    this.state = state;
    this.game = state.game;
    this.direction = data.dir || 0;
    this.fruitList = this.game.cache.getFrameData('Fruits')._frames;
    var frameName = this.fruitList[Math.floor( Math.random() * this.fruitList.length)].name;

    Phaser.Sprite.call(this, this.game, x, y, data.asset, frameName);

    this.anchor.setTo(.5);
    this.game.physics.arcade.enable(this);
    this.body.immovable = true;
    this.body.allowGravity = false;
    this.body.setSize(172, 40, 35, 30);
    this.body.blocked.up = true;
    this.body.blocked.down = true;
    // this.body.stopVelocityOnCollide = true;
    // this.body.velocity.x = 200 * this.direction;
    // this.game.physics.arcade.moveToXY(this, this.game.world.centerX, this.y, 200, this.state.DEFAULT_SPEED);
    
    this.blockMove = this.game.add.tween(this);
    this.blockMove.to({x: this.game.world.centerX }, this.state.DEFAULT_SPEED, Phaser.Easing.Cubic.In);

    if(this.direction){
        this.blockMove.start();
    }

    return this;
};

JumpStack.Block.prototype = Object.create(Phaser.Sprite.prototype);
JumpStack.Block.prototype.constructor = JumpStack.Block;

JumpStack.Block.prototype.reset = function(x, y, data){
    this.direction = data.dir || 0;
    Phaser.Sprite.prototype.reset.call(this, x, y);
    this.loadTexture(data.asset, data.frame);

    this.blockMove = this.game.add.tween(this);
    this.blockMove.to({x: this.game.world.centerX }, this.state.DEFAULT_SPEED, Phaser.Easing.Cubic.In);

    if(this.direction){
        this.blockMove.start();
    }
    this.bringToTop();
}
</script>
		<script>var JumpStack = JumpStack || {};

JumpStack.Player = function(state, x, y, data){
    this.state = state;
    this.game = state.game;
    this.isPlayerAlive = true;
    this.isPlayerJump = true;
    this.animState = data.state || 'idle';

    Phaser.Sprite.call(this, this.game, x, y, data.asset, data.frame);

    this.animations.add('idle', ['hero_jump_01'], 12, true);
    this.animations.add('jump', ['hero_jump_01','hero_jump_02',
                                'hero_jump_03','hero_jump_04',
                                'hero_jump_05'], 12, false);

    this.animations.add('fall', ['hero_jump_06',
                                'hero_jump_07','hero_jump_08',
                                'hero_jump_09','hero_jump_10'], 12, true);
    
    this.play(this.animState);

    this.anchor.setTo(.5);
    this.game.physics.arcade.enable(this);
    this.body.immovable = false;
    this.body.allowGravity = true;
    this.body.gravity.y = 1000;
    this.body.bounce.y = .2;
    this.bringToTop();
    this.body.setSize(90, 90, 20, 30);
    this.body.checkCollision.up = false;
};

JumpStack.Player.prototype = Object.create(Phaser.Sprite.prototype);
JumpStack.Player.prototype.constructor = JumpStack.Player;

JumpStack.Player.prototype.update = function() {

    if(this.body.wasTouching.left || this.body.wasTouching.right){
        this.isPlayerAlive = false;
        this.body.immovable = true;
        this.body.allowGravity = false;
    }

};

JumpStack.Player.prototype.jump = function() {

    if(this.isPlayerJump){
    }else{
        this.body.velocity.y = -700;
        this.isPlayerJump = true;
        this.play('jump');
        // if(this.body.deltaY > 0){
        //     this.play('fall');
        // }
    }

};
</script>
		<script>var JumpStack = JumpStack || {};

JumpStack.BootState = {
  init: function() {
    //loading screen will have a white background
    this.game.stage.backgroundColor = '#151332';

    //scaling options
    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;

    //have the game centered horizontally
    this.scale.pageAlignHorizontally = true;
    this.scale.pageAlignVertically = true;

    //Enable arcade physics
    this.game.physics.startSystem(Phaser.Physics.ARCADE);
    this.game.physics.arcade.gravity.y = 500;

    this.game.world.setBounds(0, 0, this.game.world.width, 9000);
  },
  preload: function() {
    //assets we'll use in the loading screen
    this.load.image('bar', 'assets/img/preloader-bar.png');
  },
  create: function() {
    this.state.start('Preload');
  }
};

</script>
		<script>var JumpStack = JumpStack || {};

JumpStack.PreloadState = {
    //load the game assets before the game starts
    preload() {
        this.load.atlasJSONHash('GameAtlas', 'assets/atlases/GameAtlas.png', 'assets/atlases/GameAtlas.json');   
        this.load.atlasJSONHash('Fruits', 'assets/atlases/FruitsAtlas.png', 'assets/atlases/FruitsAtlas.json');   
        this.load.bitmapFont('FranklinGothicHeavy36', 'assets/atlases/GameAtlas.png', 'assets/fonts/FranklinGothicHeavy-36.xml');   
    },
    create() {
        this.state.start('Game');
    }
};</script>
		<script>var JumpStack = JumpStack || {};

JumpStack.GameState = {
    create() {
        this.DEFAULT_SPEED = 1500;
        this.REPEAT_BLOCKS = 3;
        this.BOUNCE_BOOSTER = 1.05;
        this.BLOCKS_DELAY_MIN = 50;
        this.BLOCKS_DELAY_MAX = 500;
        this.introPhase = true;
        this.gameOver = false;
        var worldCenter = {x: this.game.world.centerX, y: this.game.world.centerY};
        this.background = this.game.add.tileSprite(0, -Phaser.DOM.layoutBounds.height / 3, this.game.world.width, Phaser.DOM.layoutBounds.height * 1.5, 'GameAtlas', 'bg');
        this.background.tileScale.setTo(this.background.height / this.background._frame.height);
        this.background.anchor.setTo(0,1);
        this.background.fixedToCamera = true;

        this.ground = this.game.add.sprite(this.game.world.centerX, this.game.world.height, 'GameAtlas', 'platform_01');
        this.ground.anchor.setTo(.5,1);

        this.blocks = this.game.add.group();
        this.blocks.numBlocks = 0;
        this.blocks.enableBody = true;

        var block = this.createMovingBlock(true);
        block.y = this.game.world.height - 80;

        this.blocks.towerHeight = this.getTowerHeight(this.blocks);
        this.blocks.blocksAlive = null;

        var playerSpawn = {x: worldCenter.x, y: this.game.world.height - Phaser.DOM.documentBounds.height / 1.5 };

        this.player = new JumpStack.Player(this, playerSpawn.x, playerSpawn.y, {asset: 'GameAtlas', frame: 'hero_jump_10'});

        this.game.add.existing(this.player);

        this.game.input.onDown.add(this.heroJump, this);

        this.overlay = this.game.add.tileSprite(0, 0, this.game.world.width, this.game.world.height, 'GameAtlas', 'bg_small');
        this.overlay.tileScale.setTo(this.overlay.height / this.overlay._frame.height);
        this.overlay.fixedToCamera = true;
        this.overlay.alpha = 0;

        var textStyle = {fill: '#fff', font: 'bold 50px Arial', strokeThickness: 6};

        this.score = 0;

        this.scoreText = this.game.add.text(worldCenter.x, worldCenter.y, this.score, textStyle);

        this.scoreText.anchor.setTo(.5);
        this.scoreText.fixedToCamera = true;
        this.scoreText.cameraOffset.y = 50;

        this.introText = this.game.add.text(worldCenter.x, 0, 'Tap to play', textStyle);

        this.introText.anchor.setTo(.5);
        this.introText.fixedToCamera = true;
        this.introText.cameraOffset.y = Phaser.DOM.documentBounds.height / 2.3;

        this.cameraFollow = this.player;
        // this.game.camera.setBoundsToWorld();

    },

    getTowerHeight(group) {
        let height = group.children[group.children.length-1].y;

        return height;
    },

    heroJump() {
        if(this.introPhase){
            this.introPhase = false;
            var fadeOutText = this.game.add.tween(this.introText);
            fadeOutText.to({alpha: 0}, 200);
            // .onComplete.add(() => this.createMovingBlock(), this);
            fadeOutText.killOnComplete = true;
            this.createMovingBlock();
            fadeOutText.start();

            // this.game.time.events.add(200, this.createMovingBlock, this);

            return;
        }

        if(!this.player.isPlayerAlive){
            if(this.gameOver){
                this.state.start('Game');
            }
            return;
        }

        this.player.jump();

    },

    playerHit(player, block) {
        block.blockMove.stop();
        // console.log(block.body.wasTouching.down);
        // return;

        if( player.body.bottom > block.body.top ) {
            this.blocks.blocksAlive = null;
            player.isPlayerAlive = null;
            player.body.velocity.y = -500;
            player.body.velocity.x = 20 * block.direction;
            this.blocks.forEach(item => {
                item.body.enable = false;
            }, this);

            this.game.camera.shake(.02,200, true, Phaser.Camera.SHAKE_HORIZONTAL );
            this.game.camera.flash(0xffffff, 200);

            var fadeOutTween = this.game.add.tween(this.overlay);
            fadeOutTween.to({alpha: 1}, 1000, Phaser.Easing.Cubic.Out)
            .delay(1000)
            .onComplete.add(() => {
                this.gameOver = true;
            }, this);
            this.overlay.bringToTop();
            this.scoreText.bringToTop();
            fadeOutTween.start();   //Fading in the overlay

            player.isPlayerJump = true;

            var emitter = this.game.add.emitter(player.x, player.y, 50);
            emitter.width = player.body.width - 40;
            var eVel = 50;
            var eLife = 750;
            emitter.makeParticles('GameAtlas', 'star');

            emitter.minParticleSpeed.setTo(eVel * 8 * block.direction, -eVel * 10);
            emitter.maxParticleSpeed.setTo(eVel * 5 *block.direction, -eVel * 2);
            
            emitter.maxParticleScale = 2;
            emitter.minParticleScale = .2;

            emitter.maxParticleAlpha = .9;
            emitter.minParticleAlpha = 0;

            emitter.gravity = 600;

            emitter.start(true, eLife, null, 8);

            emitter.children.forEach((ptx) => {
                var tweenScale = ptx.game.add.tween(ptx.scale);
                var tweenAlpha = ptx.game.add.tween(ptx);

                tweenScale.to({ x: 0, y: 0 }, eLife/1.5)
                .delay(eLife / 3);
                tweenAlpha.to({ alpha: 1 }, eLife/3)
                .to({ alpha: 0 }, eLife/1.5);

                tweenScale.start();
                tweenAlpha.start();
            }, emitter);

            this.floatText('Oh no...', player.x, player.bottom, 4);
        }else{
            player.isPlayerJump = false;
            player.play('idle');
            this.blocks.towerHeight = block.y;
            this.blocks.blocksAlive = null;
            if(this.player.isPlayerAlive){
                var newBlockDealy = Math.max(this.BLOCKS_DELAY_MIN,Math.random() * this.BLOCKS_DELAY_MAX);
                this.game.time.events.add(newBlockDealy, this.createMovingBlock, this);
            } 

            var perfectDist = Math.abs(block.centerX - this.game.world.centerX);
            var perfectBlock = 0;
            this.score++;
            this.scoreText.text = this.score;

            switch (true){
                case perfectDist < 5:
                    perfectBlock = 0;
                    break;
                case perfectDist < 20:
                    perfectBlock = 1;
                    break;
                case perfectDist < 30:
                    perfectBlock = 2;
                    break;
                case perfectDist < 50:
                    perfectBlock = 3;
                    break;
                case perfectDist < 100:
                    perfectBlock = 4;
                    break;
                default:
                    perfectBlock = 4;
            }

            var perfectText = 'Perfect!';

            var textTemplates = {
                perfect: ['Perfect!', 'Excelent!', 'Super!', 'Wow!', 'Great!'],
                nice: ['Nice!', 'Cool!', 'Great!', 'Hot!', ''],
                good: ['Good', 'Not bad', 'Smoooth', ''],
                close: ['Almost', 'Too colse', 'Sharp'],
                bad: ['Bad', 'Meh', 'So so']
            }

            switch (perfectBlock) {
                case 0:
                perfectText = textTemplates.perfect[ Math.floor(Math.random() * textTemplates.perfect.length )];
                break;  

                case 1:
                perfectText = textTemplates.nice[ Math.floor(Math.random() * textTemplates.nice.length )];
                break;  

                case 2:
                perfectText = textTemplates.good[ Math.floor(Math.random() * textTemplates.good.length )];
                break;  

                case 3:
                perfectText = textTemplates.close[ Math.floor(Math.random() * textTemplates.close.length )];
                break;  

                case 4:
                perfectText = textTemplates.bad[ Math.floor(Math.random() * textTemplates.bad.length )];
                break;  
            }

            this.floatText(perfectText, player.x, (perfectBlock < 4 ? player.top : player.bottom), perfectBlock);

            var emitter = this.game.add.emitter(player.x, player.y, 200);
            emitter.width = player.body.width - 40;
            var eVel = 200 - 20 * perfectBlock;
            var eLife = 1250 - 30 * perfectBlock;
            // emitter.makeParticles('GameAtlas', 'star');
            emitter.makeParticles('GameAtlas', 'white_square');

            emitter.minParticleSpeed.setTo(-eVel,-eVel * 5);
            emitter.maxParticleSpeed.setTo(eVel,-eVel * 2);
            
            emitter.maxParticleScale = 3;
            emitter.minParticleScale = .3;

            emitter.maxParticleAlpha = .9;
            emitter.minParticleAlpha = .2;

            emitter.gravity = 1000;

            this.player.bringToTop();
            emitter.start(true, eLife, null, 40 - 10 * perfectBlock);

            emitter.children.forEach((ptx) => {
                var tweenScale = ptx.game.add.tween(ptx.scale);
                var tweenAlpha = ptx.game.add.tween(ptx);

                tweenScale.to({ x: 0, y: 0 }, eLife/1.5)
                .delay(eLife / 3);
                tweenAlpha.to({ alpha: 1 }, eLife/3)
                .to({ alpha: 0 }, eLife/1.5);

                tweenScale.start();
                tweenAlpha.start();
            }, emitter);

        }
    },

    playerJumpCollide(player, block) {
        this.player.isPlayerJump = false;
        this.player.play('idle');
    },

    floatText(text, x, y, vel) {
        var textStyle = {fill: '#fff', font: '35px Arial'};

        var dir = vel < 4 ? 1 : -1;

        var floatingText = this.game.add.text(x, y, text, textStyle);
        floatingText.anchor.setTo(.5);

        var textFloatTween = this.game.add.tween(floatingText);
        textFloatTween.to({y: y - 80 * dir, alpha: 0}, 700, Phaser.Easing.Cubic.InOut);
        textFloatTween.killOnComplete = true;

        
        var textFloatTweenScale = this.game.add.tween(floatingText.scale);
        textFloatTweenScale.from({x: 0.5, y: 0.5}, 500, Phaser.Easing.Cubic.Out);

        textFloatTween.start();
        textFloatTweenScale.start();

    },

    cameraZoom() {
        this.cameraFollow = null;

        var cameraView = {
            scale: Math.min( (this.game.camera.height / (this.blocks.height + 200) ), 1),
            height: Math.max(this.getTowerHeight(this.blocks) / 2 + 50, this.game.camera.height),
            y: this.getTowerHeight(this.blocks) / 2,
            x: 500,
        };


        var cameraZoomOut = this.game.add.tween(this.game.camera.scale);
        cameraZoomOut.to({ x: cameraView.scale, y: cameraView.scale }, 1500, Phaser.Easing.Cubic.InOut)
        .delay(500);
        cameraZoomOut.start();

        var cameraZoomOutMove = this.game.add.tween(this.game.camera);
        cameraZoomOutMove.to({ x: this.game.camera.x - cameraView.x, y: this.game.world.height }, 1000, Phaser.Easing.Cubic.In)
        .delay(500);
        cameraZoomOutMove.start();
    },

    createMovingBlock(isStatic) {
        if(!this.blocks.blocksAlive){
            var dir = isStatic ? 0 : ((Math.random() > .5) ? -1 : 1);
            var index = this.blocks.numBlocks;
            this.blocks.numBlocks++;
            var speed = this.DEFAULT_SPEED * (1 + Math.floor(index / this.REPEAT_BLOCKS) / this.SPEED_BOOSTER);
            var frame = 7 + (Math.floor(index / this.REPEAT_BLOCKS) % 5);
            var frameName = 'fruit-kiwi';
            var x = this.game.world.centerX - (this.game.world.width + 300) / 2 * dir;
            var y = this.blocks.towerHeight - 2;

            // this.blocks.forEach(item => {
            //     if(item.y > (this.game.camera.view.bottom + 200)){
            //         item.kill();
            //     }
            // }, this);

            var block = this.blocks.getFirstExists(false);

            if(!block){
                block = new JumpStack.Block(this, 
                    x, 
                    y, 
                    {asset: 'Fruits', frame: frameName, dir: dir, speed: speed});

                this.blocks.add(block);
            }else{
                block.reset(x, y, {asset: 'Fruits', frame: frameName, dir: dir, speed: speed});
            }

            block.y -= block.body.height;

            if(isStatic){
                this.blocks.blocksAlive = null;
            }else{
                this.blocks.blocksAlive = block;
            }

            this.blocks.towerHeight = this.getTowerHeight(this.blocks);
        }
        return block;
        
    },

    updateGameOnRendererResize(newWidth, newHeight) {

        this.game.width = newWidth;
        this.game.height = newHeight;
        this.game.stage.width = newWidth;
        this.game.stage.height = newHeight;
        this.game.camera.setSize(newWidth, newHeight);
        // this.game.input.scale.setTo(rendererScale);
        this.background.width = newWidth;
    
    },

    update() {
        if(this.cameraFollow){
            this.game.camera.focusOnXY(this.cameraFollow.x, this.cameraFollow.y - 50);
            this.game.camera.lerp = 0.2;
        }

        this.updateGameOnRendererResize( (this.game.renderer.width / (this.game.camera.scale.x || 1)), (this.game.renderer.height / (this.game.camera.scale.y || 1)) );

        this.background.cameraOffset.y = Math.min((this.game.camera.height - (this.game.camera.view.bottom - this.game.world.bottom) / 4), this.background.height);
        
        if(this.blocks.blocksAlive){
            this.game.physics.arcade.collide(this.player, this.blocks.blocksAlive, this.playerHit, null, this);
        }
        this.game.physics.arcade.collide(this.blocks, this.player, this.playerJumpCollide, null, this);



    }
};</script>
		<script>var JumpStack = JumpStack || {};

JumpStack.game = new Phaser.Game('100%', '100%', Phaser.AUTO);

JumpStack.game.state.add('Boot', JumpStack.BootState);
JumpStack.game.state.add('Preload', JumpStack.PreloadState);
JumpStack.game.state.add('Game', JumpStack.GameState);

JumpStack.game.state.start('Boot');

</script>
	</body>
</html>
